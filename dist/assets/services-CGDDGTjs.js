var T=o=>{throw TypeError(o)};var I=(o,r,e)=>r.has(o)||T("Cannot "+e);var g=(o,r,e)=>(I(o,r,"read from private field"),e?e.call(o):r.get(o)),l=(o,r,e)=>r.has(o)?T("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(o):r.set(o,e),m=(o,r,e,t)=>(I(o,r,"write to private field"),t?t.call(o,e):r.set(o,e),e),s=(o,r,e)=>(I(o,r,"access private method"),e);import{c as F}from"./index-Bu01b8jX.js";class U extends Error{constructor(r,e){super(r),this.userMessage=e,this.name="UserFacingError"}}const i="ErrorHandlerService",p=F.mode;var $,b,E,a,v,L,y;const h=class h{constructor(r,e){l(this,a);l(this,b);l(this,E);try{console.log(`[${i}]: Constructing ErrorHandler instance`),m(this,b,r.data.getCallerInfo),m(this,E,e)}catch(t){throw new Error(`[${i} constructor]: ${t instanceof Error?t.message:t}`)}}static getInstance(r,e){try{return g(h,$)||(console.debug(`[${i}] No ErrorHandler instance exists yet. Creating new instance.`),m(h,$,new h(r,e))),console.debug(`[${i}] Returning ErrorHandler instance.`),g(h,$)}catch(t){throw new Error(`[${i}.getInstance]: ${t instanceof Error?t.message:t}`)}}handleAndReturn(r,e,t={}){try{const n=r();return n instanceof Promise?n.catch(f=>(s(this,a,y).call(this,f,e,t),t.fallback??Promise.reject(f))):n}catch(n){return s(this,a,y).call(this,n,e,t),t.fallback}}async handleAsync(r,e,t={}){try{return await r()}catch(n){throw s(this,a,y).call(this,n,e,t),n}}handleSync(r,e,t={}){try{return r()}catch(n){throw s(this,a,y).call(this,n,e,t),n}}};$=new WeakMap,b=new WeakMap,E=new WeakMap,a=new WeakSet,v=function(r,e,t){try{return r instanceof Error?`${e}: ${r.message}. Context: ${JSON.stringify(t)}`:`${e}: ${r}. Context: ${JSON.stringify(t)}`}catch(n){throw new Error(`[${i}]: Error formatting error message: ${n instanceof Error?n.message:n}`)}},L=function(r){try{return(r==null?void 0:r.stack)??new Error().stack??`[${i}]: No stack trace available.`}catch(e){throw new Error(`[${i}]: Error getting stack trace: ${e instanceof Error?e.message:e}`)}},y=function(r,e,t={}){try{const n=g(this,b).call(this),f=s(this,a,v).call(this,r,e,t.context??{});g(this,E).error(f,n),p.stackTrace&&g(this,E).debug(`Stack trace:
${s(this,a,L).call(this,r instanceof Error?r:void 0)}`,`${n}`);const k=t.userMessage??(r instanceof U?r.userMessage:void 0);k&&alert(k)}catch(n){throw new Error(`[${i}]: Error handling error: ${n instanceof Error?n.message:n}`)}},l(h,$,null);let S=h;const u="LoggerService",A=F.mode,x=A.debugLevel;var w,c,M,N,O,C;const d=class d{constructor(){l(this,c);try{console.log(`[${u}]: Constructing ${u}.`)}catch(r){throw new Error(`[${u} constructor]: ${r instanceof Error?r.message:r}`)}}static getInstance(){try{return g(d,w)||(m(d,w,new d),console.log(`[${u}]: No existing ${u} instance found. Creating new instance.`)),console.log(`[${u}]: Returning LoggerService instance.`),g(d,w)}catch(r){throw new Error(`[${u}.getInstance]: ${r instanceof Error?r.message:r}`)}}debug(r,e){s(this,c,C).call(this,r,"debug",e)}error(r,e){s(this,c,C).call(this,r,"error",e)}info(r,e){s(this,c,C).call(this,r,"info",e)}warn(r,e){s(this,c,C).call(this,r,"warn",e)}};w=new WeakMap,c=new WeakSet,M=function(r){switch(r){case"debug":return 2;case"info":return 1;case"warn":return 0;case"error":return 0;default:return 0}},N=function(){return new Date().toLocaleString("en-US",{year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",hour12:!1})},O=function(r){switch(r){case"debug":return"color: green";case"info":return"color: blue";case"warn":return"color: orange";case"error":return"color: red";default:return"color: black"}},C=function(r,e,t){if(x<s(this,c,M).call(this,e))return;const n=t,f=s(this,c,N).call(this);try{console.log(`%c[${e.toUpperCase()}]%c ${f} [${n}] %c${r}`,s(this,c,O).call(this,e),"color: gray","color: inherit")}catch(k){console.error(`[${t}.#logMessage]: Encountered an unexpected error: ${k}.`)}n==="Unknown caller"&&x>1&&A.stackTrace&&console.trace(`[${t}]: Full Stack Trace:`)},l(d,w,null);let R=d;function Y(o){console.log("[SERVICE_FACTORY]: Executing createServices.");const r={};if(console.log("[SERVICE_FACTORY]: Initializing Logger and ErrorHandler services."),r.log=R.getInstance(),r.errors=S.getInstance(o,r.log),!r.log||!r.errors)throw new Error("[SERVICE_FACTORY]: Logger and/or ErrorHandler failed to initialize.");return r}export{Y as serviceFactory};

// File: io/deserialize.js
import { createLogger } from '../logger/index.js';
import { modeData as mode } from '../data/mode.js';
const logMode = mode.logging;
const thisModule = 'io/serialize.js';
const logger = await createLogger();
async function toCSS(palette) {
    const thisMethod = 'toCSS()';
    return new Promise((resolve, reject) => {
        try {
            // 1. serialize metadata
            const metadata = `
				/* Palette Metadata */
				.palette {
					--id: "${palette.id}";
					--name: "${palette.metadata.name ?? 'Unnamed Palette'}";
					--swatches: ${palette.metadata.swatches};
					--type: "${palette.metadata.type}";
					--timestamp: "${palette.metadata.timestamp}";
					--limitDarkness: ${palette.metadata.flags.limitDarkness};
					--limitGrayness: ${palette.metadata.flags.limitGrayness};
					--limitLightness: ${palette.metadata.flags.limitLightness};
				}`.trim();
            // 2. serialize palette items
            const items = palette.items
                .map(item => {
                const backgroundColor = item.colors.css.hsl;
                return `
					/* Palette Item */
					.color {
						--cmyk-color: "${item.colors.css.cmyk}";
						--hex-color: "${item.colors.css.hex}";
						--hsl-color: "${item.colors.css.hsl}";
						--hsv-color: "${item.colors.css.hsv}";
						--lab-color: "${item.colors.css.lab}";
						--rgb-color: "${item.colors.css.rgb}";
						--xyz-color: "${item.colors.css.xyz}";
						background-color: ${backgroundColor};
					}`.trim();
            })
                .join('\n\n');
            // 3. combine CSS data
            const cssData = [metadata, items].filter(Boolean).join('\n\n');
            // 4. resolve serialized CSS data
            resolve(cssData.trim());
        }
        catch (error) {
            if (logMode.error) {
                if (logMode.verbosity > 1) {
                    logger.error(`Failed to convert palette to CSS: ${error}`, `${thisModule} > ${thisMethod}`);
                }
                else {
                    logger.error('Failed to convert palette to CSS', `${thisModule} > ${thisMethod}`);
                }
            }
            if (mode.stackTrace) {
                console.trace('Stack Trace:');
            }
            reject(new Error(`Failed to convert palette to CSS: ${error}`));
        }
    });
}
async function toJSON(palette) {
    const thisMethod = 'toJSON()';
    return new Promise((resolve, reject) => {
        try {
            const jsonData = JSON.stringify(palette, null, 2);
            resolve(jsonData);
        }
        catch (error) {
            if (logMode.error) {
                if (logMode.verbosity > 2) {
                    logger.error(`Failed to convert palette to JSON: ${error}`, `${thisModule} > ${thisMethod}`);
                }
                else {
                    logger.error('Failed to convert palette to JSON', `${thisModule} > ${thisMethod}`);
                }
            }
            if (mode.stackTrace) {
                console.trace('Stack Trace:');
            }
            reject(new Error(`Failed to convert palette to JSON: ${error}`));
        }
    });
}
async function toXML(palette) {
    const thisMethod = 'toXML()';
    return new Promise((resolve, reject) => {
        try {
            // 1. serialize palette metadata
            const metadata = `
				<Metadata>
					<Name>${palette.metadata.name ?? 'Unnamed Palette'}</Name>
					<Timestamp>${palette.metadata.timestamp}</Timestamp>
					<Swatches>${palette.metadata.swatches}</Swatches>
					<Type>${palette.metadata.type}</Type>
					<Flags>
						<LimitDarkness>${palette.metadata.flags.limitDarkness}</LimitDarkness>
						<LimitGrayness>${palette.metadata.flags.limitGrayness}</LimitGrayness>
						<LimitLightness>${palette.metadata.flags.limitLightness}</LimitLightness>
					</Flags>
				</Metadata>`.trim();
            // 2. serialize palette items
            const xmlItems = palette.items
                .map((item, index) => `
					<PaletteItem id="${index + 1}">
						<Colors>
							<Main>
								<CMYK>${item.colors.main.cmyk}</CMYK>
								<Hex>${item.colors.main.hex}</Hex>
								<HSL>${item.colors.main.hsl}</HSL>
								<HSV>${item.colors.main.hsv}</HSV>
								<LAB>${item.colors.main.lab}</LAB>
								<RGB>${item.colors.main.rgb}</RGB>
								<XYZ>${item.colors.main.xyz}</XYZ>
							</Main>
							<CSS>
								<CMYK>${item.colors.css.cmyk}</CMYK>
								<Hex>${item.colors.css.hex}</Hex>
								<HSL>${item.colors.css.hsl}</HSL>
								<HSV>${item.colors.css.hsv}</HSV>
								<LAB>${item.colors.css.lab}</LAB>
								<RGB>${item.colors.css.rgb}</RGB>
								<XYZ>${item.colors.css.xyz}</XYZ>
							</CSS>
						</Colors>
					</PaletteItem>`.trim())
                .join('\n');
            // 3. combine metadata and items into the palette XML
            const xmlData = `
				<Palette id=${palette.id}>
					${metadata}
					<Items>
						${xmlItems}
					</Items>
				</Palette>`.trim();
            resolve(xmlData.trim());
        }
        catch (error) {
            if (logMode.error) {
                if (logMode.verbosity > 2) {
                    logger.error(`Failed to convert palette to XML: ${error}`, `${thisModule} > ${thisMethod}`);
                }
                else {
                    logger.error('Failed to convert palette to XML', `${thisModule} > ${thisMethod}`);
                }
            }
            if (mode.stackTrace) {
                console.trace('Stack Trace:');
            }
            reject(new Error(`Failed to convert palette to XML: ${error}`));
        }
    });
}
export const serialize = {
    toCSS,
    toJSON,
    toXML
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2lvL3NlcmlhbGl6ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwwQkFBMEI7QUFHMUIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxRQUFRLElBQUksSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFbkQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUU3QixNQUFNLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQztBQUVyQyxNQUFNLE1BQU0sR0FBRyxNQUFNLFlBQVksRUFBRSxDQUFDO0FBRXBDLEtBQUssVUFBVSxLQUFLLENBQUMsT0FBZ0I7SUFDcEMsTUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDO0lBRTdCLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFDdEMsSUFBSSxDQUFDO1lBQ0osd0JBQXdCO1lBQ3hCLE1BQU0sUUFBUSxHQUFHOzs7Y0FHTixPQUFPLENBQUMsRUFBRTtnQkFDUixPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxpQkFBaUI7bUJBQ3ZDLE9BQU8sQ0FBQyxRQUFRLENBQUMsUUFBUTtnQkFDNUIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJO3FCQUNoQixPQUFPLENBQUMsUUFBUSxDQUFDLFNBQVM7d0JBQ3ZCLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLGFBQWE7d0JBQ3BDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLGFBQWE7eUJBQ25DLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLGNBQWM7TUFDeEQsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUVYLDZCQUE2QjtZQUM3QixNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSztpQkFDekIsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFF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LENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ3JCLE9BQU8sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDL0IsQ0FBQztZQUVELE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLENBQUM7SUFDRixDQUFDLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxTQUFTLEdBQXNDO0lBQzNELEtBQUs7SUFDTCxNQUFNO0lBQ04sS0FBSztDQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlOiBpby9kZXNlcmlhbGl6ZS5qc1xuXG5pbXBvcnQgeyBJT0ZuX01hc3RlckludGVyZmFjZSwgUGFsZXR0ZSB9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciB9IGZyb20gJy4uL2xvZ2dlci9pbmRleC5qcyc7XG5pbXBvcnQgeyBtb2RlRGF0YSBhcyBtb2RlIH0gZnJvbSAnLi4vZGF0YS9tb2RlLmpzJztcblxuY29uc3QgbG9nTW9kZSA9IG1vZGUubG9nZ2luZztcblxuY29uc3QgdGhpc01vZHVsZSA9ICdpby9zZXJpYWxpemUuanMnO1xuXG5jb25zdCBsb2dnZXIgPSBhd2FpdCBjcmVhdGVMb2dnZXIoKTtcblxuYXN5bmMgZnVuY3Rpb24gdG9DU1MocGFsZXR0ZTogUGFsZXR0ZSk6IFByb21pc2U8c3RyaW5nPiB7XG5cdGNvbnN0IHRoaXNNZXRob2QgPSAndG9DU1MoKSc7XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gMS4gc2VyaWFsaXplIG1ldGFkYXRhXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IGBcblx0XHRcdFx0LyogUGFsZXR0ZSBNZXRhZGF0YSAqL1xuXHRcdFx0XHQucGFsZXR0ZSB7XG5cdFx0XHRcdFx0LS1pZDogXCIke3BhbGV0dGUuaWR9XCI7XG5cdFx0XHRcdFx0LS1uYW1lOiBcIiR7cGFsZXR0ZS5tZXRhZGF0YS5uYW1lID8/ICdVbm5hbWVkIFBhbGV0dGUnfVwiO1xuXHRcdFx0XHRcdC0tc3dhdGNoZXM6ICR7cGFsZXR0ZS5tZXRhZGF0YS5zd2F0Y2hlc307XG5cdFx0XHRcdFx0LS10eXBlOiBcIiR7cGFsZXR0ZS5tZXRhZGF0YS50eXBlfVwiO1xuXHRcdFx0XHRcdC0tdGltZXN0YW1wOiBcIiR7cGFsZXR0ZS5tZXRhZGF0YS50aW1lc3RhbXB9XCI7XG5cdFx0XHRcdFx0LS1saW1pdERhcmtuZXNzOiAke3BhbGV0dGUubWV0YWRhdGEuZmxhZ3MubGltaXREYXJrbmVzc307XG5cdFx0XHRcdFx0LS1saW1pdEdyYXluZXNzOiAke3BhbGV0dGUubWV0YWRhdGEuZmxhZ3MubGltaXRHcmF5bmVzc307XG5cdFx0XHRcdFx0LS1saW1pdExpZ2h0bmVzczogJHtwYWxldHRlLm1ldGFkYXRhLmZsYWdzLmxpbWl0TGlnaHRuZXNzfTtcblx0XHRcdFx0fWAudHJpbSgpO1xuXG5cdFx0XHQvLyAyLiBzZXJpYWxpemUgcGFsZXR0ZSBpdGVtc1xuXHRcdFx0Y29uc3QgaXRlbXMgPSBwYWxldHRlLml0ZW1zXG5cdFx0XHRcdC5tYXAoaXRlbSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gaXRlbS5jb2xvcnMuY3NzLmhzbDtcblxuXHRcdFx0XHRcdHJldHVybiBgXG5cdFx0XHRcdFx0LyogUGFsZXR0ZSBJdGVtICovXG5cdFx0XHRcdFx0LmNvbG9yIHtcblx0XHRcdFx0XHRcdC0tY215ay1jb2xvcjogXCIke2l0ZW0uY29sb3JzLmNzcy5jbXlrfVwiO1xuXHRcdFx0XHRcdFx0LS1oZXgtY29sb3I6IFwiJHtpdGVtLmNvbG9ycy5jc3MuaGV4fVwiO1xuXHRcdFx0XHRcdFx0LS1oc2wtY29sb3I6IFwiJHtpdGVtLmNvbG9ycy5jc3MuaHNsfVwiO1xuXHRcdFx0XHRcdFx0LS1oc3YtY29sb3I6IFwiJHtpdGVtLmNvbG9ycy5jc3MuaHN2fVwiO1xuXHRcdFx0XHRcdFx0LS1sYWItY29sb3I6IFwiJHtpdGVtLmNvbG9ycy5jc3MubGFifVwiO1xuXHRcdFx0XHRcdFx0LS1yZ2ItY29sb3I6IFwiJHtpdGVtLmNvbG9ycy5jc3MucmdifVwiO1xuXHRcdFx0XHRcdFx0LS14eXotY29sb3I6IFwiJHtpdGVtLmNvbG9ycy5jc3MueHl6fVwiO1xuXHRcdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3J9O1xuXHRcdFx0XHRcdH1gLnRyaW0oKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmpvaW4oJ1xcblxcbicpO1xuXG5cdFx0XHQvLyAzLiBjb21iaW5lIENTUyBkYXRhXG5cdFx0XHRjb25zdCBjc3NEYXRhID0gW21ldGFkYXRhLCBpdGVtc10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcblxcbicpO1xuXG5cdFx0XHQvLyA0LiByZXNvbHZlIHNlcmlhbGl6ZWQgQ1NTIGRhdGFcblx0XHRcdHJlc29sdmUoY3NzRGF0YS50cmltKCkpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAobG9nTW9kZS5lcnJvcikge1xuXHRcdFx0XHRpZiAobG9nTW9kZS52ZXJib3NpdHkgPiAxKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKFxuXHRcdFx0XHRcdFx0YEZhaWxlZCB0byBjb252ZXJ0IHBhbGV0dGUgdG8gQ1NTOiAke2Vycm9yfWAsXG5cdFx0XHRcdFx0XHRgJHt0aGlzTW9kdWxlfSA+ICR7dGhpc01ldGhvZH1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0XHQnRmFpbGVkIHRvIGNvbnZlcnQgcGFsZXR0ZSB0byBDU1MnLFxuXHRcdFx0XHRcdFx0YCR7dGhpc01vZHVsZX0gPiAke3RoaXNNZXRob2R9YFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG1vZGUuc3RhY2tUcmFjZSkge1xuXHRcdFx0XHRjb25zb2xlLnRyYWNlKCdTdGFjayBUcmFjZTonKTtcblx0XHRcdH1cblxuXHRcdFx0cmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbnZlcnQgcGFsZXR0ZSB0byBDU1M6ICR7ZXJyb3J9YCkpO1xuXHRcdH1cblx0fSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRvSlNPTihwYWxldHRlOiBQYWxldHRlKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0Y29uc3QgdGhpc01ldGhvZCA9ICd0b0pTT04oKSc7XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QganNvbkRhdGEgPSBKU09OLnN0cmluZ2lmeShwYWxldHRlLCBudWxsLCAyKTtcblxuXHRcdFx0cmVzb2x2ZShqc29uRGF0YSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChsb2dNb2RlLmVycm9yKSB7XG5cdFx0XHRcdGlmIChsb2dNb2RlLnZlcmJvc2l0eSA+IDIpIHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0XHRgRmFpbGVkIHRvIGNvbnZlcnQgcGFsZXR0ZSB0byBKU09OOiAke2Vycm9yfWAsXG5cdFx0XHRcdFx0XHRgJHt0aGlzTW9kdWxlfSA+ICR7dGhpc01ldGhvZH1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0XHQnRmFpbGVkIHRvIGNvbnZlcnQgcGFsZXR0ZSB0byBKU09OJyxcblx0XHRcdFx0XHRcdGAke3RoaXNNb2R1bGV9ID4gJHt0aGlzTWV0aG9kfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtb2RlLnN0YWNrVHJhY2UpIHtcblx0XHRcdFx0Y29uc29sZS50cmFjZSgnU3RhY2sgVHJhY2U6Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBjb252ZXJ0IHBhbGV0dGUgdG8gSlNPTjogJHtlcnJvcn1gKSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdG9YTUwocGFsZXR0ZTogUGFsZXR0ZSk6IFByb21pc2U8c3RyaW5nPiB7XG5cdGNvbnN0IHRoaXNNZXRob2QgPSAndG9YTUwoKSc7XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gMS4gc2VyaWFsaXplIHBhbGV0dGUgbWV0YWRhdGFcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gYFxuXHRcdFx0XHQ8TWV0YWRhdGE+XG5cdFx0XHRcdFx0PE5hbWU+JHtwYWxldHRlLm1ldGFkYXRhLm5hbWUgPz8gJ1VubmFtZWQgUGFsZXR0ZSd9PC9OYW1lPlxuXHRcdFx0XHRcdDxUaW1lc3RhbXA+JHtwYWxldHRlLm1ldGFkYXRhLnRpbWVzdGFtcH08L1RpbWVzdGFtcD5cblx0XHRcdFx0XHQ8U3dhdGNoZXM+JHtwYWxldHRlLm1ldGFkYXRhLnN3YXRjaGVzfTwvU3dhdGNoZXM+XG5cdFx0XHRcdFx0PFR5cGU+JHtwYWxldHRlLm1ldGFkYXRhLnR5cGV9PC9UeXBlPlxuXHRcdFx0XHRcdDxGbGFncz5cblx0XHRcdFx0XHRcdDxMaW1pdERhcmtuZXNzPiR7cGFsZXR0ZS5tZXRhZGF0YS5mbGFncy5saW1pdERhcmtuZXNzfTwvTGltaXREYXJrbmVzcz5cblx0XHRcdFx0XHRcdDxMaW1pdEdyYXluZXNzPiR7cGFsZXR0ZS5tZXRhZGF0YS5mbGFncy5saW1pdEdyYXluZXNzfTwvTGltaXRHcmF5bmVzcz5cblx0XHRcdFx0XHRcdDxMaW1pdExpZ2h0bmVzcz4ke3BhbGV0dGUubWV0YWRhdGEuZmxhZ3MubGltaXRMaWdodG5lc3N9PC9MaW1pdExpZ2h0bmVzcz5cblx0XHRcdFx0XHQ8L0ZsYWdzPlxuXHRcdFx0XHQ8L01ldGFkYXRhPmAudHJpbSgpO1xuXG5cdFx0XHQvLyAyLiBzZXJpYWxpemUgcGFsZXR0ZSBpdGVtc1xuXHRcdFx0Y29uc3QgeG1sSXRlbXMgPSBwYWxldHRlLml0ZW1zXG5cdFx0XHRcdC5tYXAoKGl0ZW0sIGluZGV4KSA9PlxuXHRcdFx0XHRcdGBcblx0XHRcdFx0XHQ8UGFsZXR0ZUl0ZW0gaWQ9XCIke2luZGV4ICsgMX1cIj5cblx0XHRcdFx0XHRcdDxDb2xvcnM+XG5cdFx0XHRcdFx0XHRcdDxNYWluPlxuXHRcdFx0XHRcdFx0XHRcdDxDTVlLPiR7aXRlbS5jb2xvcnMubWFpbi5jbXlrfTwvQ01ZSz5cblx0XHRcdFx0XHRcdFx0XHQ8SGV4PiR7aXRlbS5jb2xvcnMubWFpbi5oZXh9PC9IZXg+XG5cdFx0XHRcdFx0XHRcdFx0PEhTTD4ke2l0ZW0uY29sb3JzLm1haW4uaHNsfTwvSFNMPlxuXHRcdFx0XHRcdFx0XHRcdDxIU1Y+JHtpdGVtLmNvbG9ycy5tYWluLmhzdn08L0hTVj5cblx0XHRcdFx0XHRcdFx0XHQ8TEFCPiR7aXRlbS5jb2xvcnMubWFpbi5sYWJ9PC9MQUI+XG5cdFx0XHRcdFx0XHRcdFx0PFJHQj4ke2l0ZW0uY29sb3JzLm1haW4ucmdifTwvUkdCPlxuXHRcdFx0XHRcdFx0XHRcdDxYWVo+JHtpdGVtLmNvbG9ycy5tYWluLnh5en08L1hZWj5cblx0XHRcdFx0XHRcdFx0PC9NYWluPlxuXHRcdFx0XHRcdFx0XHQ8Q1NTPlxuXHRcdFx0XHRcdFx0XHRcdDxDTVlLPiR7aXRlbS5jb2xvcnMuY3NzLmNteWt9PC9DTVlLPlxuXHRcdFx0XHRcdFx0XHRcdDxIZXg+JHtpdGVtLmNvbG9ycy5jc3MuaGV4fTwvSGV4PlxuXHRcdFx0XHRcdFx0XHRcdDxIU0w+JHtpdGVtLmNvbG9ycy5jc3MuaHNsfTwvSFNMPlxuXHRcdFx0XHRcdFx0XHRcdDxIU1Y+JHtpdGVtLmNvbG9ycy5jc3MuaHN2fTwvSFNWPlxuXHRcdFx0XHRcdFx0XHRcdDxMQUI+JHtpdGVtLmNvbG9ycy5jc3MubGFifTwvTEFCPlxuXHRcdFx0XHRcdFx0XHRcdDxSR0I+JHtpdGVtLmNvbG9ycy5jc3MucmdifTwvUkdCPlxuXHRcdFx0XHRcdFx0XHRcdDxYWVo+JHtpdGVtLmNvbG9ycy5jc3MueHl6fTwvWFlaPlxuXHRcdFx0XHRcdFx0XHQ8L0NTUz5cblx0XHRcdFx0XHRcdDwvQ29sb3JzPlxuXHRcdFx0XHRcdDwvUGFsZXR0ZUl0ZW0+YC50cmltKClcblx0XHRcdFx0KVxuXHRcdFx0XHQuam9pbignXFxuJyk7XG5cblx0XHRcdC8vIDMuIGNvbWJpbmUgbWV0YWRhdGEgYW5kIGl0ZW1zIGludG8gdGhlIHBhbGV0dGUgWE1MXG5cdFx0XHRjb25zdCB4bWxEYXRhID0gYFxuXHRcdFx0XHQ8UGFsZXR0ZSBpZD0ke3BhbGV0dGUuaWR9PlxuXHRcdFx0XHRcdCR7bWV0YWRhdGF9XG5cdFx0XHRcdFx0PEl0ZW1zPlxuXHRcdFx0XHRcdFx0JHt4bWxJdGVtc31cblx0XHRcdFx0XHQ8L0l0ZW1zPlxuXHRcdFx0XHQ8L1BhbGV0dGU+YC50cmltKCk7XG5cblx0XHRcdHJlc29sdmUoeG1sRGF0YS50cmltKCkpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAobG9nTW9kZS5lcnJvcikge1xuXHRcdFx0XHRpZiAobG9nTW9kZS52ZXJib3NpdHkgPiAyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKFxuXHRcdFx0XHRcdFx0YEZhaWxlZCB0byBjb252ZXJ0IHBhbGV0dGUgdG8gWE1MOiAke2Vycm9yfWAsXG5cdFx0XHRcdFx0XHRgJHt0aGlzTW9kdWxlfSA+ICR7dGhpc01ldGhvZH1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0XHQnRmFpbGVkIHRvIGNvbnZlcnQgcGFsZXR0ZSB0byBYTUwnLFxuXHRcdFx0XHRcdFx0YCR7dGhpc01vZHVsZX0gPiAke3RoaXNNZXRob2R9YFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG1vZGUuc3RhY2tUcmFjZSkge1xuXHRcdFx0XHRjb25zb2xlLnRyYWNlKCdTdGFjayBUcmFjZTonKTtcblx0XHRcdH1cblxuXHRcdFx0cmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbnZlcnQgcGFsZXR0ZSB0byBYTUw6ICR7ZXJyb3J9YCkpO1xuXHRcdH1cblx0fSk7XG59XG5cbmV4cG9ydCBjb25zdCBzZXJpYWxpemU6IElPRm5fTWFzdGVySW50ZXJmYWNlWydzZXJpYWxpemUnXSA9IHtcblx0dG9DU1MsXG5cdHRvSlNPTixcblx0dG9YTUxcbn07XG4iXX0=